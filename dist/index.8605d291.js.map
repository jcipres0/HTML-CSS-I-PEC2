{"mappings":"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","sources":["<anon>","src/mapkick.js"],"sourcesContent":["/*\r\n * Mapkick.js v0.2.6\r\n * Create beautiful, interactive maps with one line of JavaScript\r\n * https://github.com/ankane/mapkick.js\r\n * MIT License\r\n */ (function(global, factory) {\n    typeof exports === \"object\" && typeof module !== \"undefined\" ? module.exports = factory() : typeof define === \"function\" && define.amd ? define(factory) : (global = typeof globalThis !== \"undefined\" ? globalThis : global || self, global.Mapkick = factory());\n})(this, function() {\n    \"use strict\";\n    function getElement(element) {\n        if (typeof element === \"string\") {\n            var elementId = element;\n            element = document.getElementById(element);\n            if (!element) throw new Error(\"No element with id \" + elementId);\n        }\n        return element;\n    }\n    // check for hex or named color\n    function validateColor(color) {\n        if (!/^#([0-9a-f]{3}){1,2}$/i.test(color) && !/^[a-z]+$/i.test(color)) throw new Error(\"Invalid color\");\n    }\n    function createMarkerImage(library, color) {\n        // set height to center vertically\n        var height = 41;\n        var width = 27;\n        var scale = 2;\n        // get marker svg\n        var svg = new library.Marker()._element.querySelector(\"svg\");\n        // make displayable and center vertically\n        svg.removeAttribute(\"display\");\n        svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n        svg.setAttribute(\"height\", height);\n        svg.setAttribute(\"width\", width);\n        svg.setAttribute(\"viewBox\", \"0 0 \" + width + \" \" + height);\n        validateColor(color);\n        // set color\n        svg.querySelector(\"*[fill='#3FB1CE']\").setAttribute(\"fill\", color);\n        // add border to inner circle\n        var circles = svg.querySelectorAll(\"circle\");\n        var circle = circles[circles.length - 1];\n        if (circles.length == 1) {\n            // need to insert new circle for mapbox-gl v2\n            var c = circle.cloneNode();\n            c.setAttribute(\"fill\", \"#000000\");\n            c.setAttribute(\"opacity\", 0.25);\n            circle.parentNode.insertBefore(c, circle);\n        }\n        circle.setAttribute(\"r\", 4.5);\n        // create image\n        var image = new Image(width * scale, height * scale);\n        image.src = \"data:image/svg+xml;utf8,\" + encodeURIComponent(svg.outerHTML);\n        return image;\n    }\n    var maps = {};\n    var BaseMap = function BaseMap(element, data, options, mapType) {\n        var this$1$1 = this;\n        if (!Mapkick.library && typeof window !== \"undefined\") Mapkick.library = window.mapboxgl || window.maplibregl || null;\n        var library = Mapkick.library;\n        if (!library) throw new Error(\"No mapping library found\");\n        var map;\n        var trails = {};\n        var groupedData = {};\n        var timestamps = [];\n        var timeIndex = 0;\n        element = getElement(element);\n        if (element.id) maps[element.id] = this;\n        function getJSON(element, url, success) {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, true);\n            xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n            xhr.onload = function() {\n                if (xhr.status === 200) success(JSON.parse(xhr.responseText));\n                else showError(element, xhr.statusText);\n            };\n            xhr.send();\n        }\n        function onMapLoad(callback) {\n            if (map.loaded()) callback();\n            else map.on(\"load\", callback);\n        }\n        function toTimestamp(ts) {\n            if (typeof ts === \"number\") return ts;\n            else return new Date(ts).getTime() / 1000;\n        }\n        function generateReplayMap(element, data, options) {\n            // group data\n            for(var i = 0; i < data.length; i++){\n                var row = data[i];\n                var ts = toTimestamp(row.time);\n                if (ts) {\n                    if (!groupedData[ts]) groupedData[ts] = [];\n                    groupedData[ts].push(row);\n                    bounds.extend(rowCoordinates(row));\n                }\n            }\n            for(var i$1 in groupedData)if (Object.prototype.hasOwnProperty.call(groupedData, i$1)) timestamps.push(parseInt(i$1));\n            timestamps.sort();\n            // create map\n            generateMap(element, groupedData[timestamps[timeIndex]], options);\n            onMapLoad(function() {\n                setTimeout(function() {\n                    nextFrame(element, options);\n                }, 100);\n            });\n        }\n        function nextFrame(element, options) {\n            timeIndex++;\n            updateMap(element, groupedData[timestamps[timeIndex]], options);\n            if (timeIndex < timestamps.length - 1) setTimeout(function() {\n                nextFrame(element, options);\n            }, 100);\n        }\n        function showError(element, message) {\n            element.textContent = message;\n        }\n        function errorCatcher(element, data, options, callback) {\n            try {\n                callback(element, data, options);\n            } catch (err) {\n                showError(element, err.message);\n                throw err;\n            }\n        }\n        function fetchData(element, data, options, callback) {\n            if (typeof data === \"string\") getJSON(element, data, function(newData) {\n                errorCatcher(element, newData, options, callback);\n            });\n            else if (typeof data === \"function\") data(function(newData) {\n                errorCatcher(element, newData, options, callback);\n            }, function(message) {\n                showError(element, message);\n            });\n            else errorCatcher(element, data, options, callback);\n        }\n        function updateMap(element, data, options) {\n            onLayersReady(function() {\n                if (options.trail) {\n                    recordTrails(data, options.trail);\n                    map.getSource(\"trails\").setData(generateTrailsGeoJSON(data));\n                }\n                map.getSource(\"objects\").setData(generateGeoJSON(data, options));\n            });\n        }\n        // use Map instead of object for security\n        var markerIds = new window.Map();\n        function generateGeoJSON(data, options) {\n            var geojson = {\n                type: \"FeatureCollection\",\n                features: []\n            };\n            for(var i = 0; i < data.length; i++){\n                var row = data[i];\n                var properties = Object.assign({}, row);\n                var geometry = void 0;\n                if (mapType === \"point\") {\n                    if (!properties.icon) properties.icon = options.defaultIcon || \"mapkick\";\n                    properties.mapkickIconSize = properties.icon === \"mapkick\" ? 0.5 : 1;\n                    properties.mapkickIconAnchor = properties.icon === \"mapkick\" ? \"bottom\" : \"center\";\n                    properties.mapkickIconOffset = properties.icon === \"mapkick\" ? [\n                        0,\n                        10\n                    ] : [\n                        0,\n                        0\n                    ];\n                    if (properties.icon === \"mapkick\") {\n                        var color = properties.color || markerOptions.color || \"#f84d4d\";\n                        var markerId = markerIds.get(color);\n                        if (markerId === undefined) {\n                            markerId = markerIds.size;\n                            validateColor(color);\n                            markerIds.set(color, markerId);\n                        }\n                        properties.icon = \"mapkick-\" + markerId;\n                    }\n                    var coordinates = rowCoordinates(row);\n                    if (!coordinates[1]) throw new Error(\"missing latitude (index: \" + i + \")\");\n                    if (!coordinates[0]) throw new Error(\"missing longitude (index: \" + i + \")\");\n                    geometry = {\n                        type: \"Point\",\n                        coordinates: coordinates\n                    };\n                } else {\n                    geometry = row.geometry;\n                    if (!geometry) throw new Error(\"missing geometry (index: \" + i + \")\");\n                    delete properties.geometry;\n                    properties.mapkickColor = properties.color || markerOptions.color || \"#0090ff\";\n                }\n                geojson.features.push({\n                    type: \"Feature\",\n                    id: i,\n                    geometry: geometry,\n                    properties: properties\n                });\n            }\n            return geojson;\n        }\n        function rowCoordinates(row) {\n            return [\n                row.longitude || row.lng || row.lon,\n                row.latitude || row.lat\n            ];\n        }\n        function getTrailId(row) {\n            return row.id;\n        }\n        function recordTrails(data, trailOptions) {\n            for(var i = 0; i < data.length; i++){\n                var row = data[i];\n                var trailId = getTrailId(row);\n                if (!trails[trailId]) trails[trailId] = [];\n                trails[trailId].push(rowCoordinates(row));\n                if (trailOptions && trailOptions.len && trails[trailId].length > trailOptions.len) trails[trailId].shift();\n            }\n        }\n        function generateTrailsGeoJSON(data) {\n            var geojson = {\n                type: \"FeatureCollection\",\n                features: []\n            };\n            for(var i = 0; i < data.length; i++){\n                var row = data[i];\n                geojson.features.push({\n                    type: \"Feature\",\n                    geometry: {\n                        type: \"LineString\",\n                        coordinates: trails[getTrailId(row)]\n                    }\n                });\n            }\n            return geojson;\n        }\n        function generateLabelGeoJSON(data) {\n            var geojson = {\n                type: \"FeatureCollection\",\n                features: []\n            };\n            for(var i = 0; i < data.features.length; i++){\n                var feature = data.features[i];\n                var coordinates = void 0;\n                // use center for now\n                var bounds = new library.LngLatBounds();\n                extendBounds(bounds, feature.geometry);\n                if (!bounds.isEmpty()) {\n                    var center = bounds.getCenter();\n                    coordinates = [\n                        center.lng,\n                        center.lat\n                    ];\n                }\n                if (coordinates) geojson.features.push({\n                    type: \"Feature\",\n                    id: i,\n                    geometry: {\n                        type: \"Point\",\n                        coordinates: coordinates\n                    },\n                    properties: feature.properties\n                });\n            }\n            return geojson;\n        }\n        function layerBeforeFill(map) {\n            // place below labels\n            var layers = map.getStyle().layers;\n            var beforeId;\n            for(var i = layers.length - 1; i >= 0; i--){\n                var layer = layers[i];\n                // TODO improve\n                if (!(layer.metadata && layer.metadata[\"mapbox:featureComponent\"] === \"place-labels\")) break;\n                beforeId = layer.id;\n            }\n            return beforeId;\n        }\n        function addLayer(name, geojson) {\n            var centersById = {};\n            map.addSource(name, {\n                type: \"geojson\",\n                data: geojson\n            });\n            if (mapType === \"point\") {\n                // use a symbol layer for markers for performance\n                // https://docs.mapbox.com/help/getting-started/add-markers/#approach-1-adding-markers-inside-a-map\n                // use separate layers to prevent labels from overlapping markers\n                map.addLayer({\n                    id: name + \"-text\",\n                    source: name,\n                    type: \"symbol\",\n                    layout: {\n                        \"text-field\": \"{label}\",\n                        \"text-size\": 11,\n                        \"text-anchor\": \"top\",\n                        \"text-offset\": [\n                            0,\n                            1\n                        ]\n                    },\n                    paint: {\n                        \"text-halo-color\": \"rgba(255, 255, 255, 1)\",\n                        \"text-halo-width\": 1\n                    }\n                });\n                map.addLayer({\n                    id: name,\n                    source: name,\n                    type: \"symbol\",\n                    layout: {\n                        \"icon-image\": \"{icon}-15\",\n                        \"icon-allow-overlap\": true,\n                        \"icon-size\": {\n                            type: \"identity\",\n                            property: \"mapkickIconSize\"\n                        },\n                        \"icon-anchor\": {\n                            type: \"identity\",\n                            property: \"mapkickIconAnchor\"\n                        },\n                        \"icon-offset\": {\n                            type: \"identity\",\n                            property: \"mapkickIconOffset\"\n                        }\n                    }\n                });\n            } else {\n                var beforeId = layerBeforeFill(map);\n                var outlineId = name + \"-outline\";\n                map.addLayer({\n                    id: outlineId,\n                    source: name,\n                    type: \"line\",\n                    paint: {\n                        \"line-color\": {\n                            type: \"identity\",\n                            property: \"mapkickColor\"\n                        },\n                        \"line-opacity\": 0.7,\n                        \"line-width\": 1\n                    }\n                }, beforeId);\n                map.addLayer({\n                    id: name,\n                    source: name,\n                    type: \"fill\",\n                    paint: {\n                        \"fill-color\": {\n                            type: \"identity\",\n                            property: \"mapkickColor\"\n                        },\n                        \"fill-opacity\": 0.3\n                    }\n                }, outlineId);\n                var labelName = name + \"-text\";\n                var labelData = generateLabelGeoJSON(geojson);\n                for(var i = 0; i < labelData.features.length; i++){\n                    var feature = labelData.features[i];\n                    centersById[feature.id] = feature.geometry.coordinates;\n                }\n                map.addSource(labelName, {\n                    type: \"geojson\",\n                    data: labelData\n                });\n                map.addLayer({\n                    id: name + \"-text\",\n                    source: labelName,\n                    type: \"symbol\",\n                    layout: {\n                        \"text-field\": \"{label}\",\n                        \"text-size\": 11\n                    },\n                    paint: {\n                        \"text-halo-color\": \"rgba(255, 255, 255, 1)\",\n                        \"text-halo-width\": 1\n                    }\n                });\n            }\n            var hover = !(\"hover\" in tooltipOptions) || tooltipOptions.hover;\n            var popupOptions = {\n                closeButton: false,\n                closeOnClick: false\n            };\n            if (!hover) popupOptions.anchor = \"bottom\";\n            // create a popup\n            var popup = new library.Popup(popupOptions);\n            // ensure tooltip is visible\n            var panMap = function panMap(map, popup) {\n                var style = window.getComputedStyle(popup.getElement());\n                var matrix = new DOMMatrixReadOnly(style.transform);\n                var padding = 5;\n                var extra = 5;\n                var top = matrix.m42;\n                var left = matrix.m41;\n                // TODO add right and bottom\n                if (top < padding || left < padding) map.panBy([\n                    Math.min(left - padding - extra, 0),\n                    Math.min(top - padding - extra, 0)\n                ]);\n            };\n            var showPopup = function showPopup(e) {\n                var feature = selectedFeature(e);\n                var tooltip = feature.properties.tooltip;\n                if (!tooltip) return;\n                if (mapType === \"point\" && feature.properties.icon.startsWith(\"mapkick-\")) popup.options.offset = {\n                    \"top\": [\n                        0,\n                        14\n                    ],\n                    \"top-left\": [\n                        0,\n                        14\n                    ],\n                    \"top-right\": [\n                        0,\n                        14\n                    ],\n                    \"bottom\": [\n                        0,\n                        -44\n                    ],\n                    \"bottom-left\": [\n                        0,\n                        -44\n                    ],\n                    \"bottom-right\": [\n                        0,\n                        -44\n                    ],\n                    \"left\": [\n                        14,\n                        0\n                    ],\n                    \"right\": [\n                        -14,\n                        0\n                    ]\n                };\n                else popup.options.offset = 14;\n                var coordinates;\n                if (mapType === \"point\") coordinates = feature.geometry.coordinates;\n                else coordinates = centersById[feature.id];\n                // add the tooltip\n                popup.setLngLat(coordinates);\n                if (tooltipOptions.html) popup.setHTML(tooltip);\n                else popup.setText(tooltip);\n                popup.addTo(map);\n                // fix blurriness for non-retina screens\n                // https://github.com/mapbox/mapbox-gl-js/pull/3258\n                if (popup._container.offsetWidth % 2 !== 0) popup._container.style.width = popup._container.offsetWidth + 1 + \"px\";\n                if (mapType !== \"area\") panMap(map, popup);\n            };\n            var getLatitude = function getLatitude(feature) {\n                return feature.geometry.coordinates[1];\n            };\n            var selectedFeature = function selectedFeature(e) {\n                var features = e.features;\n                var selected = features[0];\n                for(var i = 1; i < features.length; i++){\n                    var feature = features[i];\n                    // no need to handle ties since this is stable\n                    if (getLatitude(feature) < getLatitude(selected)) selected = feature;\n                }\n                return selected;\n            };\n            if (!hover) {\n                var currentPoint = null;\n                map.on(\"click\", name, function(e) {\n                    var point = selectedFeature(e).id;\n                    if (point !== currentPoint) {\n                        showPopup(e);\n                        currentPoint = point;\n                        e.mapkickPopupOpened = true;\n                    }\n                });\n                map.on(\"click\", function(e) {\n                    if (!e.mapkickPopupOpened) {\n                        popup.remove();\n                        currentPoint = null;\n                    }\n                });\n            }\n            map.on(\"mouseenter\", name, function(e) {\n                var tooltip = selectedFeature(e).properties.tooltip;\n                if (tooltip) {\n                    map.getCanvas().style.cursor = \"pointer\";\n                    if (hover) showPopup(e);\n                }\n            });\n            map.on(\"mouseleave\", name, function() {\n                map.getCanvas().style.cursor = \"\";\n                if (hover) popup.remove();\n            });\n        }\n        function extendBounds(bounds, geometry) {\n            if (geometry.type === \"Point\") bounds.extend(geometry.coordinates);\n            else if (geometry.type === \"Polygon\") {\n                var coordinates = geometry.coordinates[0];\n                for(var j = 0; j < coordinates.length; j++)bounds.extend(coordinates[j]);\n            } else if (geometry.type === \"MultiPolygon\") {\n                var coordinates$1 = geometry.coordinates;\n                for(var j$1 = 0; j$1 < coordinates$1.length; j$1++){\n                    var polygon = coordinates$1[j$1][0];\n                    for(var k = 0; k < polygon.length; k++)bounds.extend(polygon[k]);\n                }\n            }\n        }\n        var generateMap = function generateMap(element, data, options) {\n            var geojson = generateGeoJSON(data, options);\n            options = options || {};\n            for(var i = 0; i < geojson.features.length; i++)extendBounds(bounds, geojson.features[i].geometry);\n            // remove any child elements\n            element.textContent = \"\";\n            var style = options.style;\n            if (!style) {\n                var isMapLibre = !(\"accessToken\" in library) || /^1\\.1[45]/.test(library.version);\n                if (isMapLibre) throw new Error(\"style required for MapLibre\");\n                else style = \"mapbox://styles/mapbox/streets-v12\";\n            }\n            var zoom = options.zoom;\n            var center = options.center;\n            if (!center) {\n                if (!bounds.isEmpty()) center = bounds.getCenter();\n                else {\n                    center = [\n                        0,\n                        0\n                    ];\n                    if (!zoom) zoom = 1;\n                }\n            }\n            if (!zoom) zoom = 15;\n            var mapOptions = {\n                container: element,\n                style: style,\n                dragRotate: false,\n                touchZoomRotate: false,\n                center: center,\n                zoom: zoom\n            };\n            if (!options.style) mapOptions.projection = \"mercator\";\n            if (options.accessToken) mapOptions.accessToken = options.accessToken;\n            if (options.library) Object.assign(mapOptions, options.library);\n            map = new library.Map(mapOptions);\n            if (options.controls) map.addControl(new library.NavigationControl({\n                showCompass: false\n            }));\n            if (!options.zoom) {\n                // hack to prevent error\n                if (!map.style.stylesheet) map.style.stylesheet = {};\n                // check zoom for hash library option\n                if (!bounds.isEmpty() && map.getZoom() === zoom) map.fitBounds(bounds, {\n                    padding: 40,\n                    animate: false,\n                    maxZoom: 15\n                });\n            }\n            this$1$1.map = map;\n            onMapLoad(function() {\n                if (options.trail) {\n                    recordTrails(data);\n                    map.addSource(\"trails\", {\n                        type: \"geojson\",\n                        data: generateTrailsGeoJSON([])\n                    });\n                    map.addLayer({\n                        id: \"trails\",\n                        source: \"trails\",\n                        type: \"line\",\n                        layout: {\n                            \"line-join\": \"round\",\n                            \"line-cap\": \"round\"\n                        },\n                        paint: {\n                            \"line-color\": \"#888\",\n                            \"line-width\": 2\n                        }\n                    });\n                }\n                var outstanding = markerIds.size;\n                function checkReady() {\n                    if (outstanding !== 0) {\n                        outstanding--;\n                        return;\n                    }\n                    addLayer(\"objects\", geojson);\n                    layersReady = true;\n                    var cb;\n                    while(cb = layersReadyQueue.shift())cb();\n                }\n                // load marker images\n                markerIds.forEach(function(id, color) {\n                    var image = createMarkerImage(library, color);\n                    image.addEventListener(\"load\", function() {\n                        map.addImage(\"mapkick-\" + id + \"-15\", image);\n                        checkReady();\n                    });\n                });\n                checkReady();\n            });\n        };\n        var layersReady = false;\n        var layersReadyQueue = [];\n        function onLayersReady(callback) {\n            if (layersReady) callback();\n            else layersReadyQueue.push(callback);\n        }\n        // main\n        options = options || {};\n        options = Object.assign({}, Mapkick.options, options);\n        var tooltipOptions = options.tooltips || {};\n        var markerOptions = options.markers || {};\n        var bounds = new library.LngLatBounds();\n        if (options.replay) fetchData(element, data, options, generateReplayMap);\n        else {\n            fetchData(element, data, options, generateMap);\n            if (options.refresh) this.intervalId = setInterval(function() {\n                fetchData(element, data, options, updateMap);\n            }, options.refresh * 1000);\n        }\n    };\n    BaseMap.prototype.getMapObject = function getMapObject() {\n        return this.map;\n    };\n    BaseMap.prototype.destroy = function destroy() {\n        this.stopRefresh();\n        if (this.map) {\n            this.map.remove();\n            this.map = null;\n        }\n    };\n    BaseMap.prototype.stopRefresh = function stopRefresh() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n            this.intervalId = null;\n        }\n    };\n    var Map = /*@__PURE__*/ function(BaseMap) {\n        function Map(element, data, options) {\n            BaseMap.call(this, element, data, options, \"point\");\n        }\n        if (BaseMap) Map.__proto__ = BaseMap;\n        Map.prototype = Object.create(BaseMap && BaseMap.prototype);\n        Map.prototype.constructor = Map;\n        return Map;\n    }(BaseMap);\n    var AreaMap = /*@__PURE__*/ function(BaseMap) {\n        function AreaMap(element, data, options) {\n            BaseMap.call(this, element, data, options, \"area\");\n        }\n        if (BaseMap) AreaMap.__proto__ = BaseMap;\n        AreaMap.prototype = Object.create(BaseMap && BaseMap.prototype);\n        AreaMap.prototype.constructor = AreaMap;\n        return AreaMap;\n    }(BaseMap);\n    var Mapkick = {\n        Map: Map,\n        AreaMap: AreaMap,\n        maps: maps,\n        options: {},\n        library: null\n    };\n    Mapkick.use = function(library) {\n        Mapkick.library = library;\n    };\n    // not ideal, but allows for simpler integration\n    if (typeof window !== \"undefined\" && !window.Mapkick) {\n        window.Mapkick = Mapkick;\n        // use setTimeout so mapping library can come later in same JS file\n        setTimeout(function() {\n            window.dispatchEvent(new Event(\"mapkick:load\"));\n        }, 0);\n    }\n    return Mapkick;\n});\n\n//# sourceMappingURL=index.8605d291.js.map\n","/*\r\n * Mapkick.js v0.2.6\r\n * Create beautiful, interactive maps with one line of JavaScript\r\n * https://github.com/ankane/mapkick.js\r\n * MIT License\r\n */\r\n\r\n(function (global, factory) {\r\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n  typeof define === 'function' && define.amd ? define(factory) :\r\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Mapkick = factory());\r\n})(this, (function () { 'use strict';\r\n\r\n  function getElement(element) {\r\n    if (typeof element === \"string\") {\r\n      var elementId = element;\r\n      element = document.getElementById(element);\r\n      if (!element) {\r\n        throw new Error(\"No element with id \" + elementId)\r\n      }\r\n    }\r\n    return element\r\n  }\r\n\r\n  // check for hex or named color\r\n  function validateColor(color) {\r\n    if (!/^#([0-9a-f]{3}){1,2}$/i.test(color) && !/^[a-z]+$/i.test(color)) {\r\n      throw new Error(\"Invalid color\")\r\n    }\r\n  }\r\n\r\n  function createMarkerImage(library, color) {\r\n    // set height to center vertically\r\n    var height = 41;\r\n    var width = 27;\r\n    var scale = 2;\r\n\r\n    // get marker svg\r\n    var svg = (new library.Marker())._element.querySelector(\"svg\");\r\n\r\n    // make displayable and center vertically\r\n    svg.removeAttribute(\"display\");\r\n    svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\r\n    svg.setAttribute(\"height\", height);\r\n    svg.setAttribute(\"width\", width);\r\n    svg.setAttribute(\"viewBox\", (\"0 0 \" + width + \" \" + height));\r\n\r\n    validateColor(color);\r\n\r\n    // set color\r\n    svg.querySelector(\"*[fill='#3FB1CE']\").setAttribute(\"fill\", color);\r\n\r\n    // add border to inner circle\r\n    var circles = svg.querySelectorAll(\"circle\");\r\n    var circle = circles[circles.length - 1];\r\n    if (circles.length == 1) {\r\n      // need to insert new circle for mapbox-gl v2\r\n      var c = circle.cloneNode();\r\n      c.setAttribute(\"fill\", \"#000000\");\r\n      c.setAttribute(\"opacity\", 0.25);\r\n      circle.parentNode.insertBefore(c, circle);\r\n    }\r\n    circle.setAttribute(\"r\", 4.5);\r\n\r\n    // create image\r\n    var image = new Image(width * scale, height * scale);\r\n    image.src = \"data:image/svg+xml;utf8,\" + (encodeURIComponent(svg.outerHTML));\r\n    return image\r\n  }\r\n\r\n  var maps = {};\r\n\r\n  var BaseMap = function BaseMap(element, data, options, mapType) {\r\n    var this$1$1 = this;\r\n\r\n    if (!Mapkick.library && typeof window !== \"undefined\") {\r\n      Mapkick.library = window.mapboxgl || window.maplibregl || null;\r\n    }\r\n\r\n    var library = Mapkick.library;\r\n    if (!library) {\r\n      throw new Error(\"No mapping library found\")\r\n    }\r\n\r\n    var map;\r\n    var trails = {};\r\n    var groupedData = {};\r\n    var timestamps = [];\r\n    var timeIndex = 0;\r\n\r\n    element = getElement(element);\r\n\r\n    if (element.id) {\r\n      maps[element.id] = this;\r\n    }\r\n\r\n    function getJSON(element, url, success) {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open(\"GET\", url, true);\r\n      xhr.setRequestHeader(\"Content-Type\", \"application/json\");\r\n      xhr.onload = function () {\r\n        if (xhr.status === 200) {\r\n          success(JSON.parse(xhr.responseText));\r\n        } else {\r\n          showError(element, xhr.statusText);\r\n        }\r\n      };\r\n      xhr.send();\r\n    }\r\n\r\n    function onMapLoad(callback) {\r\n      if (map.loaded()) {\r\n        callback();\r\n      } else {\r\n        map.on(\"load\", callback);\r\n      }\r\n    }\r\n\r\n    function toTimestamp(ts) {\r\n      if (typeof ts === \"number\") {\r\n        return ts\r\n      } else {\r\n        return (new Date(ts)).getTime() / 1000\r\n      }\r\n    }\r\n\r\n    function generateReplayMap(element, data, options) {\r\n      // group data\r\n      for (var i = 0; i < data.length; i++) {\r\n        var row = data[i];\r\n        var ts = toTimestamp(row.time);\r\n        if (ts) {\r\n          if (!groupedData[ts]) {\r\n            groupedData[ts] = [];\r\n          }\r\n          groupedData[ts].push(row);\r\n          bounds.extend(rowCoordinates(row));\r\n        }\r\n      }\r\n\r\n      for (var i$1 in groupedData) {\r\n        if (Object.prototype.hasOwnProperty.call(groupedData, i$1)) {\r\n          timestamps.push(parseInt(i$1));\r\n        }\r\n      }\r\n      timestamps.sort();\r\n\r\n      // create map\r\n      generateMap(element, groupedData[timestamps[timeIndex]], options);\r\n\r\n      onMapLoad(function () {\r\n        setTimeout(function () {\r\n          nextFrame(element, options);\r\n        }, 100);\r\n      });\r\n    }\r\n\r\n    function nextFrame(element, options) {\r\n      timeIndex++;\r\n\r\n      updateMap(element, groupedData[timestamps[timeIndex]], options);\r\n\r\n      if (timeIndex < timestamps.length - 1) {\r\n        setTimeout(function () {\r\n          nextFrame(element, options);\r\n        }, 100);\r\n      }\r\n    }\r\n\r\n    function showError(element, message) {\r\n      element.textContent = message;\r\n    }\r\n\r\n    function errorCatcher(element, data, options, callback) {\r\n      try {\r\n        callback(element, data, options);\r\n      } catch (err) {\r\n        showError(element, err.message);\r\n        throw err\r\n      }\r\n    }\r\n\r\n    function fetchData(element, data, options, callback) {\r\n      if (typeof data === \"string\") {\r\n        getJSON(element, data, function (newData) {\r\n          errorCatcher(element, newData, options, callback);\r\n        });\r\n      } else if (typeof data === \"function\") {\r\n        data(function (newData) {\r\n          errorCatcher(element, newData, options, callback);\r\n        }, function (message) {\r\n          showError(element, message);\r\n        });\r\n      } else {\r\n        errorCatcher(element, data, options, callback);\r\n      }\r\n    }\r\n\r\n    function updateMap(element, data, options) {\r\n      onLayersReady(function () {\r\n        if (options.trail) {\r\n          recordTrails(data, options.trail);\r\n          map.getSource(\"trails\").setData(generateTrailsGeoJSON(data));\r\n        }\r\n        map.getSource(\"objects\").setData(generateGeoJSON(data, options));\r\n      });\r\n    }\r\n\r\n    // use Map instead of object for security\r\n    var markerIds = new window.Map();\r\n\r\n    function generateGeoJSON(data, options) {\r\n      var geojson = {\r\n        type: \"FeatureCollection\",\r\n        features: []\r\n      };\r\n\r\n      for (var i = 0; i < data.length; i++) {\r\n        var row = data[i];\r\n        var properties = Object.assign({}, row);\r\n        var geometry = (void 0);\r\n\r\n        if (mapType === \"point\") {\r\n          if (!properties.icon) {\r\n            properties.icon = options.defaultIcon || \"mapkick\";\r\n          }\r\n          properties.mapkickIconSize = properties.icon === \"mapkick\" ? 0.5 : 1;\r\n          properties.mapkickIconAnchor = properties.icon === \"mapkick\" ? \"bottom\" : \"center\";\r\n          properties.mapkickIconOffset = properties.icon === \"mapkick\" ? [0, 10] : [0, 0];\r\n\r\n          if (properties.icon === \"mapkick\") {\r\n            var color = properties.color || markerOptions.color || \"#f84d4d\";\r\n\r\n            var markerId = markerIds.get(color);\r\n            if (markerId === undefined) {\r\n              markerId = markerIds.size;\r\n              validateColor(color);\r\n              markerIds.set(color, markerId);\r\n            }\r\n\r\n            properties.icon = \"mapkick-\" + markerId;\r\n          }\r\n\r\n          var coordinates = rowCoordinates(row);\r\n\r\n          if (!coordinates[1]) {\r\n            throw new Error((\"missing latitude (index: \" + i + \")\"))\r\n          }\r\n\r\n          if (!coordinates[0]) {\r\n            throw new Error((\"missing longitude (index: \" + i + \")\"))\r\n          }\r\n\r\n          geometry = {\r\n            type: \"Point\",\r\n            coordinates: coordinates\r\n          };\r\n        } else {\r\n          geometry = row.geometry;\r\n\r\n          if (!geometry) {\r\n            throw new Error((\"missing geometry (index: \" + i + \")\"))\r\n          }\r\n\r\n          delete properties.geometry;\r\n\r\n          properties.mapkickColor = properties.color || markerOptions.color || \"#0090ff\";\r\n\r\n        }\r\n\r\n        geojson.features.push({\r\n          type: \"Feature\",\r\n          id: i,\r\n          geometry: geometry,\r\n          properties: properties\r\n        });\r\n      }\r\n\r\n      return geojson\r\n    }\r\n\r\n    function rowCoordinates(row) {\r\n      return [row.longitude || row.lng || row.lon, row.latitude || row.lat]\r\n    }\r\n\r\n    function getTrailId(row) {\r\n      return row.id\r\n    }\r\n\r\n    function recordTrails(data, trailOptions) {\r\n      for (var i = 0; i < data.length; i++) {\r\n        var row = data[i];\r\n        var trailId = getTrailId(row);\r\n        if (!trails[trailId]) {\r\n          trails[trailId] = [];\r\n        }\r\n        trails[trailId].push(rowCoordinates(row));\r\n        if (trailOptions && trailOptions.len && trails[trailId].length > trailOptions.len) {\r\n          trails[trailId].shift();\r\n        }\r\n      }\r\n    }\r\n\r\n    function generateTrailsGeoJSON(data) {\r\n      var geojson = {\r\n        type: \"FeatureCollection\",\r\n        features: []\r\n      };\r\n\r\n      for (var i = 0; i < data.length; i++) {\r\n        var row = data[i];\r\n        geojson.features.push({\r\n          type: \"Feature\",\r\n          geometry: {\r\n            type: \"LineString\",\r\n            coordinates: trails[getTrailId(row)]\r\n          }\r\n        });\r\n      }\r\n\r\n      return geojson\r\n    }\r\n\r\n    function generateLabelGeoJSON(data) {\r\n      var geojson = {\r\n        type: \"FeatureCollection\",\r\n        features: []\r\n      };\r\n\r\n      for (var i = 0; i < data.features.length; i++) {\r\n        var feature = data.features[i];\r\n        var coordinates = (void 0);\r\n\r\n        // use center for now\r\n        var bounds = new library.LngLatBounds();\r\n        extendBounds(bounds, feature.geometry);\r\n        if (!bounds.isEmpty()) {\r\n          var center = bounds.getCenter();\r\n          coordinates = [center.lng, center.lat];\r\n        }\r\n\r\n        if (coordinates) {\r\n          geojson.features.push({\r\n            type: \"Feature\",\r\n            id: i,\r\n            geometry: {\r\n              type: \"Point\",\r\n              coordinates: coordinates\r\n            },\r\n            properties: feature.properties\r\n          });\r\n        }\r\n      }\r\n\r\n      return geojson\r\n    }\r\n\r\n    function layerBeforeFill(map) {\r\n      // place below labels\r\n      var layers = map.getStyle().layers;\r\n      var beforeId;\r\n      for (var i = layers.length - 1; i >= 0; i--) {\r\n        var layer = layers[i];\r\n        // TODO improve\r\n        if (!(layer.metadata && layer.metadata[\"mapbox:featureComponent\"] === \"place-labels\")) {\r\n          break\r\n        }\r\n        beforeId = layer.id;\r\n      }\r\n      return beforeId\r\n    }\r\n\r\n    function addLayer(name, geojson) {\r\n      var centersById = {};\r\n\r\n      map.addSource(name, {\r\n        type: \"geojson\",\r\n        data: geojson\r\n      });\r\n\r\n      if (mapType === \"point\") {\r\n        // use a symbol layer for markers for performance\r\n        // https://docs.mapbox.com/help/getting-started/add-markers/#approach-1-adding-markers-inside-a-map\r\n        // use separate layers to prevent labels from overlapping markers\r\n        map.addLayer({\r\n          id: (name + \"-text\"),\r\n          source: name,\r\n          type: \"symbol\",\r\n          layout: {\r\n            \"text-field\": \"{label}\",\r\n            \"text-size\": 11,\r\n            \"text-anchor\": \"top\",\r\n            \"text-offset\": [0, 1]\r\n          },\r\n          paint: {\r\n            \"text-halo-color\": \"rgba(255, 255, 255, 1)\",\r\n            \"text-halo-width\": 1\r\n          }\r\n        });\r\n        map.addLayer({\r\n          id: name,\r\n          source: name,\r\n          type: \"symbol\",\r\n          layout: {\r\n            \"icon-image\": \"{icon}-15\",\r\n            \"icon-allow-overlap\": true,\r\n            \"icon-size\": {type: \"identity\", property: \"mapkickIconSize\"},\r\n            \"icon-anchor\": {type: \"identity\", property: \"mapkickIconAnchor\"},\r\n            \"icon-offset\": {type: \"identity\", property: \"mapkickIconOffset\"}\r\n          }\r\n        });\r\n      } else {\r\n        var beforeId = layerBeforeFill(map);\r\n\r\n        var outlineId = name + \"-outline\";\r\n        map.addLayer({\r\n          id: outlineId,\r\n          source: name,\r\n          type: \"line\",\r\n          paint: {\r\n            \"line-color\": {type: \"identity\", property: \"mapkickColor\"},\r\n            \"line-opacity\": 0.7,\r\n            \"line-width\": 1\r\n          }\r\n        }, beforeId);\r\n\r\n        map.addLayer({\r\n          id: name,\r\n          source: name,\r\n          type: \"fill\",\r\n          paint: {\r\n            \"fill-color\": {type: \"identity\", property: \"mapkickColor\"},\r\n            \"fill-opacity\": 0.3\r\n          }\r\n        }, outlineId);\r\n\r\n        var labelName = name + \"-text\";\r\n        var labelData = generateLabelGeoJSON(geojson);\r\n\r\n        for (var i = 0; i < labelData.features.length; i++) {\r\n          var feature = labelData.features[i];\r\n          centersById[feature.id] = feature.geometry.coordinates;\r\n        }\r\n\r\n        map.addSource(labelName, {\r\n          type: \"geojson\",\r\n          data: labelData\r\n        });\r\n\r\n        map.addLayer({\r\n          id: (name + \"-text\"),\r\n          source: labelName,\r\n          type: \"symbol\",\r\n          layout: {\r\n            \"text-field\": \"{label}\",\r\n            \"text-size\": 11\r\n          },\r\n          paint: {\r\n            \"text-halo-color\": \"rgba(255, 255, 255, 1)\",\r\n            \"text-halo-width\": 1\r\n          }\r\n        });\r\n      }\r\n\r\n      var hover = !(\"hover\" in tooltipOptions) || tooltipOptions.hover;\r\n\r\n      var popupOptions = {\r\n        closeButton: false,\r\n        closeOnClick: false\r\n      };\r\n      if (!hover) {\r\n        popupOptions.anchor = \"bottom\";\r\n      }\r\n\r\n      // create a popup\r\n      var popup = new library.Popup(popupOptions);\r\n\r\n      // ensure tooltip is visible\r\n      var panMap = function (map, popup) {\r\n        var style = window.getComputedStyle(popup.getElement());\r\n        var matrix = new DOMMatrixReadOnly(style.transform);\r\n        var padding = 5;\r\n        var extra = 5;\r\n        var top = matrix.m42;\r\n        var left = matrix.m41;\r\n\r\n        // TODO add right and bottom\r\n        if (top < padding || left < padding) {\r\n          map.panBy([Math.min(left - padding - extra, 0), Math.min(top - padding - extra, 0)]);\r\n        }\r\n      };\r\n\r\n      var showPopup = function (e) {\r\n        var feature = selectedFeature(e);\r\n        var tooltip = feature.properties.tooltip;\r\n\r\n        if (!tooltip) {\r\n          return\r\n        }\r\n\r\n        if (mapType === \"point\" && feature.properties.icon.startsWith(\"mapkick-\")) {\r\n          popup.options.offset = {\r\n            \"top\": [0, 14],\r\n            \"top-left\": [0, 14],\r\n            \"top-right\": [0, 14],\r\n            \"bottom\": [0, -44],\r\n            \"bottom-left\": [0, -44],\r\n            \"bottom-right\": [0, -44],\r\n            \"left\": [14, 0],\r\n            \"right\": [-14, 0]\r\n          };\r\n        } else {\r\n          popup.options.offset = 14;\r\n        }\r\n\r\n        var coordinates;\r\n        if (mapType === \"point\") {\r\n          coordinates = feature.geometry.coordinates;\r\n        } else {\r\n          coordinates = centersById[feature.id];\r\n        }\r\n\r\n        // add the tooltip\r\n        popup.setLngLat(coordinates);\r\n        if (tooltipOptions.html) {\r\n          popup.setHTML(tooltip);\r\n        } else {\r\n          popup.setText(tooltip);\r\n        }\r\n        popup.addTo(map);\r\n\r\n        // fix blurriness for non-retina screens\r\n        // https://github.com/mapbox/mapbox-gl-js/pull/3258\r\n        if (popup._container.offsetWidth % 2 !== 0) {\r\n          popup._container.style.width = popup._container.offsetWidth + 1 + \"px\";\r\n        }\r\n\r\n        if (mapType !== \"area\") {\r\n          panMap(map, popup);\r\n        }\r\n      };\r\n\r\n      var getLatitude = function (feature) {\r\n        return feature.geometry.coordinates[1]\r\n      };\r\n\r\n      var selectedFeature = function (e) {\r\n        var features = e.features;\r\n        var selected = features[0];\r\n        for (var i = 1; i < features.length; i++) {\r\n          var feature = features[i];\r\n          // no need to handle ties since this is stable\r\n          if (getLatitude(feature) < getLatitude(selected)) {\r\n            selected = feature;\r\n          }\r\n        }\r\n        return selected\r\n      };\r\n\r\n      if (!hover) {\r\n        var currentPoint = null;\r\n\r\n        map.on(\"click\", name, function (e) {\r\n          var point = selectedFeature(e).id;\r\n          if (point !== currentPoint) {\r\n            showPopup(e);\r\n            currentPoint = point;\r\n            e.mapkickPopupOpened = true;\r\n          }\r\n        });\r\n\r\n        map.on(\"click\", function (e) {\r\n          if (!e.mapkickPopupOpened) {\r\n            popup.remove();\r\n            currentPoint = null;\r\n          }\r\n        });\r\n      }\r\n\r\n      map.on(\"mouseenter\", name, function (e) {\r\n        var tooltip = selectedFeature(e).properties.tooltip;\r\n\r\n        if (tooltip) {\r\n          map.getCanvas().style.cursor = \"pointer\";\r\n\r\n          if (hover) {\r\n            showPopup(e);\r\n          }\r\n        }\r\n      });\r\n\r\n      map.on(\"mouseleave\", name, function () {\r\n        map.getCanvas().style.cursor = \"\";\r\n\r\n        if (hover) {\r\n          popup.remove();\r\n        }\r\n      });\r\n    }\r\n\r\n    function extendBounds(bounds, geometry) {\r\n      if (geometry.type === \"Point\") {\r\n        bounds.extend(geometry.coordinates);\r\n      } else if (geometry.type === \"Polygon\") {\r\n        var coordinates = geometry.coordinates[0];\r\n        for (var j = 0; j < coordinates.length; j++) {\r\n          bounds.extend(coordinates[j]);\r\n        }\r\n      } else if (geometry.type === \"MultiPolygon\") {\r\n        var coordinates$1 = geometry.coordinates;\r\n        for (var j$1 = 0; j$1 < coordinates$1.length; j$1++) {\r\n          var polygon = coordinates$1[j$1][0];\r\n          for (var k = 0; k < polygon.length; k++) {\r\n            bounds.extend(polygon[k]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    var generateMap = function (element, data, options) {\r\n      var geojson = generateGeoJSON(data, options);\r\n      options = options || {};\r\n\r\n      for (var i = 0; i < geojson.features.length; i++) {\r\n        extendBounds(bounds, geojson.features[i].geometry);\r\n      }\r\n\r\n      // remove any child elements\r\n      element.textContent = \"\";\r\n\r\n      var style = options.style;\r\n      if (!style) {\r\n        var isMapLibre = !(\"accessToken\" in library) || /^1\\.1[45]/.test(library.version);\r\n        if (isMapLibre) {\r\n          throw new Error(\"style required for MapLibre\")\r\n        } else {\r\n          style = \"mapbox://styles/mapbox/streets-v12\";\r\n        }\r\n      }\r\n\r\n      var zoom = options.zoom;\r\n      var center = options.center;\r\n      if (!center) {\r\n        if (!bounds.isEmpty()) {\r\n          center = bounds.getCenter();\r\n        } else {\r\n          center = [0, 0];\r\n          if (!zoom) {\r\n            zoom = 1;\r\n          }\r\n        }\r\n      }\r\n      if (!zoom) {\r\n        zoom = 15;\r\n      }\r\n\r\n      var mapOptions = {\r\n        container: element,\r\n        style: style,\r\n        dragRotate: false,\r\n        touchZoomRotate: false,\r\n        center: center,\r\n        zoom: zoom\r\n      };\r\n      if (!options.style) {\r\n        mapOptions.projection = \"mercator\";\r\n      }\r\n      if (options.accessToken) {\r\n        mapOptions.accessToken = options.accessToken;\r\n      }\r\n      if (options.library) {\r\n        Object.assign(mapOptions, options.library);\r\n      }\r\n      map = new library.Map(mapOptions);\r\n\r\n      if (options.controls) {\r\n        map.addControl(new library.NavigationControl({showCompass: false}));\r\n      }\r\n\r\n      if (!options.zoom) {\r\n        // hack to prevent error\r\n        if (!map.style.stylesheet) {\r\n          map.style.stylesheet = {};\r\n        }\r\n\r\n        // check zoom for hash library option\r\n        if (!bounds.isEmpty() && map.getZoom() === zoom) {\r\n          map.fitBounds(bounds, {padding: 40, animate: false, maxZoom: 15});\r\n        }\r\n      }\r\n\r\n      this$1$1.map = map;\r\n\r\n      onMapLoad(function () {\r\n        if (options.trail) {\r\n          recordTrails(data);\r\n\r\n          map.addSource(\"trails\", {\r\n            type: \"geojson\",\r\n            data: generateTrailsGeoJSON([])\r\n          });\r\n\r\n          map.addLayer({\r\n            id: \"trails\",\r\n            source: \"trails\",\r\n            type: \"line\",\r\n            layout: {\r\n              \"line-join\": \"round\",\r\n              \"line-cap\": \"round\"\r\n            },\r\n            paint: {\r\n              \"line-color\": \"#888\",\r\n              \"line-width\": 2\r\n            }\r\n          });\r\n        }\r\n\r\n        var outstanding = markerIds.size;\r\n\r\n        function checkReady() {\r\n          if (outstanding !== 0) {\r\n            outstanding--;\r\n            return\r\n          }\r\n\r\n          addLayer(\"objects\", geojson);\r\n\r\n          layersReady = true;\r\n          var cb;\r\n          while ((cb = layersReadyQueue.shift())) {\r\n            cb();\r\n          }\r\n        }\r\n\r\n        // load marker images\r\n        markerIds.forEach(function (id, color) {\r\n          var image = createMarkerImage(library, color);\r\n          image.addEventListener(\"load\", function () {\r\n            map.addImage((\"mapkick-\" + id + \"-15\"), image);\r\n            checkReady();\r\n          });\r\n        });\r\n\r\n        checkReady();\r\n      });\r\n    };\r\n\r\n    var layersReady = false;\r\n    var layersReadyQueue = [];\r\n    function onLayersReady(callback) {\r\n      if (layersReady) {\r\n        callback();\r\n      } else {\r\n        layersReadyQueue.push(callback);\r\n      }\r\n    }\r\n\r\n    // main\r\n\r\n    options = options || {};\r\n    options = Object.assign({}, Mapkick.options, options);\r\n    var tooltipOptions = options.tooltips || {};\r\n    var markerOptions = options.markers || {};\r\n    var bounds = new library.LngLatBounds();\r\n\r\n    if (options.replay) {\r\n      fetchData(element, data, options, generateReplayMap);\r\n    } else {\r\n      fetchData(element, data, options, generateMap);\r\n\r\n      if (options.refresh) {\r\n        this.intervalId = setInterval(function () {\r\n          fetchData(element, data, options, updateMap);\r\n        }, options.refresh * 1000);\r\n      }\r\n    }\r\n  };\r\n\r\n  BaseMap.prototype.getMapObject = function getMapObject () {\r\n    return this.map\r\n  };\r\n\r\n  BaseMap.prototype.destroy = function destroy () {\r\n    this.stopRefresh();\r\n\r\n    if (this.map) {\r\n      this.map.remove();\r\n      this.map = null;\r\n    }\r\n  };\r\n\r\n  BaseMap.prototype.stopRefresh = function stopRefresh () {\r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId);\r\n      this.intervalId = null;\r\n    }\r\n  };\r\n\r\n  var Map = /*@__PURE__*/(function (BaseMap) {\r\n    function Map(element, data, options) {\r\n      BaseMap.call(this, element, data, options, \"point\");\r\n    }\r\n\r\n    if ( BaseMap ) Map.__proto__ = BaseMap;\r\n    Map.prototype = Object.create( BaseMap && BaseMap.prototype );\r\n    Map.prototype.constructor = Map;\r\n\r\n    return Map;\r\n  }(BaseMap));\r\n\r\n  var AreaMap = /*@__PURE__*/(function (BaseMap) {\r\n    function AreaMap(element, data, options) {\r\n      BaseMap.call(this, element, data, options, \"area\");\r\n    }\r\n\r\n    if ( BaseMap ) AreaMap.__proto__ = BaseMap;\r\n    AreaMap.prototype = Object.create( BaseMap && BaseMap.prototype );\r\n    AreaMap.prototype.constructor = AreaMap;\r\n\r\n    return AreaMap;\r\n  }(BaseMap));\r\n\r\n  var Mapkick = {\r\n    Map: Map,\r\n    AreaMap: AreaMap,\r\n    maps: maps,\r\n    options: {},\r\n    library: null\r\n  };\r\n\r\n  Mapkick.use = function (library) {\r\n    Mapkick.library = library;\r\n  };\r\n\r\n  // not ideal, but allows for simpler integration\r\n  if (typeof window !== \"undefined\" && !window.Mapkick) {\r\n    window.Mapkick = Mapkick;\r\n\r\n    // use setTimeout so mapping library can come later in same JS file\r\n    setTimeout(function () {\r\n      window.dispatchEvent(new Event(\"mapkick:load\"));\r\n    }, 0);\r\n  }\r\n\r\n  return Mapkick;\r\n\r\n}));"],"names":["global","factory","validateColor","color","test","Error","maps","BaseMap","element","data","options","mapType","map","this$1$1","Mapkick","library","window","mapboxgl","maplibregl","trails","groupedData","timestamps","timeIndex","onMapLoad","callback","loaded","on","showError","message","textContent","errorCatcher","err","fetchData","getJSON","success","xhr","newData","XMLHttpRequest","open","setRequestHeader","onload","status","JSON","parse","responseText","statusText","send","updateMap","trail","recordTrails","getSource","setData","generateTrailsGeoJSON","generateGeoJSON","layersReady","layersReadyQueue","push","getElement","elementId","document","getElementById","id","markerIds","Map","geojson","type","features","i","length","row","properties","Object","assign","geometry","icon","defaultIcon","mapkickIconSize","mapkickIconAnchor","mapkickIconOffset","markerOptions","markerId","get","undefined","size","set","coordinates","rowCoordinates","mapkickColor","longitude","lng","lon","latitude","lat","trailOptions","trailId","len","shift","extendBounds","bounds","extend","j","coordinates$1","j$1","polygon","k","generateMap","style","version","zoom","center","isEmpty","getCenter","mapOptions","container","dragRotate","touchZoomRotate","projection","accessToken","controls","addControl","NavigationControl","showCompass","stylesheet","getZoom","fitBounds","padding","animate","maxZoom","addSource","addLayer","source","layout","paint","outstanding","checkReady","cb","name","centersById","property","beforeId","layerBeforeFill","layers","getStyle","layer","metadata","outlineId","labelName","labelData","generateLabelGeoJSON","feature","LngLatBounds","hover","tooltipOptions","popupOptions","closeButton","closeOnClick","anchor","popup","Popup","panMap","matrix","DOMMatrixReadOnly","getComputedStyle","transform","top","m42","left","m41","panBy","Math","min","showPopup","e","selectedFeature","tooltip","startsWith","offset","setLngLat","html","setHTML","setText","addTo","_container","offsetWidth","width","getLatitude","selected","currentPoint","point","mapkickPopupOpened","remove","getCanvas","cursor","forEach","image","createMarkerImage","svg","Marker","_element","querySelector","removeAttribute","setAttribute","circles","querySelectorAll","circle","c","cloneNode","parentNode","insertBefore","Image","height","src","encodeURIComponent","outerHTML","addEventListener","addImage","tooltips","markers","replay","ts","time","Date","getTime","i$1","prototype","hasOwnProperty","call","parseInt","sort","setTimeout","nextFrame","refresh","intervalId","setInterval","getMapObject","destroy","stopRefresh","clearInterval","__proto__","create","constructor","AreaMap","use","dispatchEvent","Event","exports","module","define","amd","globalThis","self","scale","url","toTimestamp","generateReplayMap","onLayersReady","getTrailId","extra","isMapLibre"],"version":3,"file":"index.8605d291.js.map"}